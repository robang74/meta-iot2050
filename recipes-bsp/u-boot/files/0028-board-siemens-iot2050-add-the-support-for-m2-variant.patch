From e07f2283e716a1fb3946e8d3892378fb4192dcbd Mon Sep 17 00:00:00 2001
From: chao zeng <chao.zeng@siemens.com>
Date: Thu, 30 Jun 2022 10:53:05 +0800
Subject: [PATCH 28/32] board: siemens: iot2050: add the support for m2 variant

For normal boot, load and configure m.2 device through boot.scr
For securey boot enable, go through UEFI, fixup the compatible
before loading the efibootguard incase we can load correct m.2 different
variant device tree.

Signed-off-by: chao zeng <chao.zeng@siemens.com>
---
 board/siemens/iot2050/board.c | 269 +++++++++++++++++++++++++++++++++-
 1 file changed, 267 insertions(+), 2 deletions(-)

diff --git a/board/siemens/iot2050/board.c b/board/siemens/iot2050/board.c
index be30b9c4d1..18d606ff31 100644
--- a/board/siemens/iot2050/board.c
+++ b/board/siemens/iot2050/board.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
  * Board specific initialization for IOT2050
- * Copyright (c) Siemens AG, 2018-2021
+ * Copyright (c) Siemens AG, 2018-2022
  *
  * Authors:
  *   Le Jin <le.jin@siemens.com>
@@ -23,6 +23,7 @@
 #include <asm/arch/hardware.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
+#include <fdt_support.h>
 
 #define IOT2050_INFO_MAGIC		0x20502050
 
@@ -47,6 +48,244 @@ struct iot2050_info {
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#define M2_CFG_PIN_NUM    4
+#define PCIE_MUX_CTRL_NUM 3
+
+static char *fdt_fix_string;
+
+struct gpio_config {
+	char *label;
+	char *gpio_name;
+};
+
+enum serdes0_supported_interface {
+	USB30 = 0,
+	PCIE0_LANE0,
+	SGMII_LANE0,
+};
+
+enum serdes1_supported_interface {
+	PCIE1_LANE0 = 0,
+	PCIE0_LANE1,
+	SGMII_LANE1,
+};
+
+enum m2_connector_combination_type {
+	BKEY_PCIEX2_EKEY_NONE = 0,
+	BKEY_PCIE_EKEY_PCIE,
+	BKEY_USB30_EKEY_PCIE,
+};
+
+struct serdes_combination {
+	enum m2_connector_combination_type m2_connector_type;
+	enum serdes0_supported_interface  serdes0_interface;
+	enum serdes1_supported_interface  serdes1_interface;
+};
+
+/* definition is from M.2 Spec */
+struct m2_device_config_decodes {
+	char config_0;
+	char config_1;
+	char config_2;
+	char config_3;
+};
+
+struct serdes_mux_control_pin {
+	char ctrl_usb30_pcie0_lane0;
+	char ctrl_pcie1_pcie0;
+	char ctrl_usb30_pcie0_lane1;
+};
+
+struct m2_config_table {
+	struct m2_device_config_decodes	m2_config_decodes;
+	struct serdes_mux_control_pin serdes_mux_ctrl_pin;
+	struct serdes_combination serdes_select;
+};
+
+static struct gpio_config serdes_mux_ctl_pin_info[PCIE_MUX_CTRL_NUM] = {
+	{"CTRL_USB30_PCIE0_LANE0", "gpio@600000_88"},
+	{"CTRL_PCIE1_PCIE0",       "gpio@600000_82"},
+	{"CTRL_USB30_PCIE0_LANE1", "gpio@600000_89"},
+};
+
+static struct gpio_config m2_bkey_cfg_pin_info[M2_CFG_PIN_NUM] = {
+	{"KEY_CONFIG_0", "gpio@601000_18"},
+	{"KEY_CONFIG_1", "gpio@601000_19"},
+	{"KEY_CONFIG_2", "gpio@601000_88"},
+	{"KEY_CONFIG_3", "gpio@601000_89"},
+};
+
+static struct m2_config_table m2_config_table[] = {
+	{{0, 1, 0, 0}, {0, 0, 1}, {BKEY_PCIEX2_EKEY_NONE, PCIE0_LANE0, PCIE0_LANE1}},
+	{{0, 0, 1, 0}, {0, 1, 0}, {BKEY_PCIE_EKEY_PCIE, PCIE0_LANE0, PCIE1_LANE0}},
+	{{0, 1, 1, 0}, {0, 1, 0}, {BKEY_PCIE_EKEY_PCIE, PCIE0_LANE0, PCIE1_LANE0}},
+	{{1, 0, 0, 1}, {0, 1, 0}, {BKEY_PCIE_EKEY_PCIE, PCIE0_LANE0, PCIE1_LANE0}},
+	{{1, 1, 0, 1}, {0, 1, 0}, {BKEY_PCIE_EKEY_PCIE, PCIE0_LANE0, PCIE1_LANE0}},
+	{{0, 0, 0, 1}, {1, 1, 0}, {BKEY_USB30_EKEY_PCIE, USB30, PCIE1_LANE0}},
+	{{0, 1, 0, 1}, {1, 1, 0}, {BKEY_USB30_EKEY_PCIE, USB30, PCIE1_LANE0}},
+	{{0, 0, 1, 1}, {1, 1, 0}, {BKEY_USB30_EKEY_PCIE, USB30, PCIE1_LANE0}},
+	{{0, 1, 1, 1}, {1, 1, 0}, {BKEY_USB30_EKEY_PCIE, USB30, PCIE1_LANE0}},
+	{{1, 0, 1, 1}, {1, 1, 0}, {BKEY_USB30_EKEY_PCIE, USB30, PCIE1_LANE0}},
+};
+
+static struct gpio_config m2_enable_power = {"P3V3_M2_EN", "gpio@601000_17"};
+
+static int get_pinvalue(const char *gpio_name, const char *label)
+{
+	struct gpio_desc gpio;
+
+	if (dm_gpio_lookup_name(gpio_name, &gpio) < 0 ||
+	    dm_gpio_request(&gpio, label) < 0 ||
+	    dm_gpio_set_dir_flags(&gpio, GPIOD_IS_IN) < 0)
+		return false;
+
+	return dm_gpio_get_value(&gpio);
+}
+
+static void set_pinvalue(const char *gpio_name, const char *label, int value)
+{
+	struct gpio_desc gpio;
+
+	if (dm_gpio_lookup_name(gpio_name, &gpio) < 0 ||
+	    dm_gpio_request(&gpio, label) < 0 ||
+	    dm_gpio_set_dir_flags(&gpio, GPIOD_IS_OUT) < 0) {
+		pr_err("IOT2050: Can not set the pin value\n");
+		return;
+	}
+	dm_gpio_set_value(&gpio, value);
+}
+
+static void get_m2_config_decodes(struct m2_device_config_decodes *decodes)
+{
+	decodes->config_0 = get_pinvalue(m2_bkey_cfg_pin_info[0].gpio_name,
+								    m2_bkey_cfg_pin_info[0].label);
+	decodes->config_1 = get_pinvalue(m2_bkey_cfg_pin_info[1].gpio_name,
+								    m2_bkey_cfg_pin_info[1].label);
+	decodes->config_2 = get_pinvalue(m2_bkey_cfg_pin_info[2].gpio_name,
+								    m2_bkey_cfg_pin_info[2].label);
+	decodes->config_3 = get_pinvalue(m2_bkey_cfg_pin_info[3].gpio_name,
+								    m2_bkey_cfg_pin_info[3].label);
+}
+
+static void get_serdes_combination(struct serdes_combination *serdes_combination,
+									int m2_connector_type)
+{
+	switch (m2_connector_type) {
+	case BKEY_PCIEX2_EKEY_NONE:
+		*serdes_combination = m2_config_table[0].serdes_select;
+		break;
+	case BKEY_PCIE_EKEY_PCIE:
+		*serdes_combination = m2_config_table[1].serdes_select;
+		break;
+	case BKEY_USB30_EKEY_PCIE:
+		*serdes_combination = m2_config_table[5].serdes_select;
+		break;
+	default:
+		*serdes_combination = m2_config_table[5].serdes_select;
+		break;
+	}
+}
+
+static void update_m2_load_info(struct serdes_combination serdes_combination, const char **fdt_name)
+{
+	if (serdes_combination.serdes0_interface == PCIE0_LANE0 &&
+		serdes_combination.serdes1_interface == PCIE0_LANE1) {
+		fdt_fix_string = "siemens,iot2050-advanced-m2-pciex2";
+		*fdt_name = "ti/k3-am6548-iot2050-advanced-m2-bkey-pciex2.dtb";
+	} else if (serdes_combination.serdes0_interface == USB30 &&
+			serdes_combination.serdes1_interface == PCIE0_LANE1) {
+		fdt_fix_string = "siemens,iot2050-advanced-m2-usb3-pcie";
+		*fdt_name = "ti/k3-am6548-iot2050-advanced-m2-bkey-usb3-ekey-pcie.dtb";
+	} else if (serdes_combination.serdes0_interface == PCIE0_LANE0 &&
+			serdes_combination.serdes1_interface == PCIE1_LANE0) {
+		fdt_fix_string = "siemens,iot2050-advanced-m2-pcie-pcie";
+		*fdt_name = "ti/k3-am6548-iot2050-advanced-m2-bkey-pcie-ekey-pcie.dtb";
+	} else {
+		fdt_fix_string = "siemens,iot2050-advanced-m2-usb3-pcie";
+		*fdt_name = "ti/k3-am6548-iot2050-advanced-m2-bkey-usb3-ekey-pcie.dtb";
+	}
+}
+
+static void get_serdes_mux_ctrl(struct serdes_mux_control_pin *serdes_mux_ctrl_info,
+				int m2_connector_type)
+{
+	switch (m2_connector_type) {
+	case BKEY_PCIEX2_EKEY_NONE:
+		*serdes_mux_ctrl_info = m2_config_table[0].serdes_mux_ctrl_pin;
+		break;
+	case BKEY_PCIE_EKEY_PCIE:
+		*serdes_mux_ctrl_info = m2_config_table[1].serdes_mux_ctrl_pin;
+		break;
+	case BKEY_USB30_EKEY_PCIE:
+		*serdes_mux_ctrl_info = m2_config_table[5].serdes_mux_ctrl_pin;
+		break;
+	default:
+		*serdes_mux_ctrl_info = m2_config_table[5].serdes_mux_ctrl_pin;
+		break;
+	}
+}
+
+static void configure_serdes_mux(struct serdes_combination serdes_selected_combination)
+{
+	struct serdes_mux_control_pin serdes_mux_ctrl_info;
+
+	get_serdes_mux_ctrl(&serdes_mux_ctrl_info, serdes_selected_combination.m2_connector_type);
+
+	set_pinvalue(serdes_mux_ctl_pin_info[0].gpio_name, serdes_mux_ctl_pin_info[0].label,
+				serdes_mux_ctrl_info.ctrl_usb30_pcie0_lane0);
+	set_pinvalue(serdes_mux_ctl_pin_info[1].gpio_name, serdes_mux_ctl_pin_info[1].label,
+				serdes_mux_ctrl_info.ctrl_pcie1_pcie0);
+	set_pinvalue(serdes_mux_ctl_pin_info[2].gpio_name, serdes_mux_ctl_pin_info[2].label,
+				serdes_mux_ctrl_info.ctrl_usb30_pcie0_lane1);
+}
+
+
+static void set_m2_load_info(const char **fdt_name)
+{
+	int i;
+	int config_table_size = ARRAY_SIZE(m2_config_table);
+	struct m2_device_config_decodes	config;
+	struct serdes_combination current_serdes_combination = {BKEY_USB30_EKEY_PCIE,
+								USB30, PCIE1_LANE0};
+	enum m2_connector_combination_type current_m2_connector_type;
+
+	if (env_get("m2_manual_config")) {
+		printf("Maunal Select M.2 Configuration\n");
+		current_m2_connector_type = simple_strtoul(env_get("m2_manual_config"), NULL, 10);
+		get_serdes_combination(&current_serdes_combination, current_m2_connector_type);
+	} else { /*auto detect*/
+		get_m2_config_decodes(&config);
+		for (i = 0; i < config_table_size; i++) {
+			if (!memcmp(&config, &m2_config_table[i].m2_config_decodes,
+						sizeof(struct m2_device_config_decodes))) {
+				current_serdes_combination =  m2_config_table[i].serdes_select;
+				break;
+			}
+		}
+	}
+
+	update_m2_load_info(current_serdes_combination, fdt_name);
+	configure_serdes_mux(current_serdes_combination);
+}
+
+/*
+ * M.2 Board is a Variant Baesed On PG2 board
+ */
+static bool board_is_m2(void)
+{
+	struct iot2050_info *info = IOT2050_INFO_DATA;
+
+	return info->magic == IOT2050_INFO_MAGIC &&
+		strcmp((char *)info->name, "IOT2050-ADVANCED-M2") == 0;
+}
+
+static void m2_power_enable(void)
+{
+	/* enable m.2 connector power */
+	set_pinvalue(m2_enable_power.gpio_name, m2_enable_power.label, 1);
+	udelay(4 * 100);
+}
+
 static bool board_is_advanced(void)
 {
 	struct iot2050_info *info = IOT2050_INFO_DATA;
@@ -89,7 +328,6 @@ void set_board_info_env(void)
 	env_set("board_a5e", info->a5e);
 	env_set("fw_version", PLAIN_VERSION);
 	env_set("seboot_version", info->seboot_version);
-
 	if (IS_ENABLED(CONFIG_NET)) {
 		/* set MAC addresses to ensure forwarding to the OS */
 		for (mac_cnt = 0; mac_cnt < info->mac_addr_cnt; mac_cnt++) {
@@ -103,6 +341,8 @@ void set_board_info_env(void)
 	if (board_is_advanced()) {
 		if (IS_ENABLED(CONFIG_TARGET_IOT2050_A53_PG1))
 			fdtfile = "ti/k3-am6548-iot2050-advanced.dtb";
+		else if(board_is_m2())
+			fdtfile = "ti/k3-am6548-iot2050-advanced-m2-bkey-usb3-ekey-pcie.dtb";
 		else
 			fdtfile = "ti/k3-am6548-iot2050-advanced-pg2.dtb";
 	} else {
@@ -118,6 +358,16 @@ void set_board_info_env(void)
 	env_save();
 }
 
+void update_m2_board_info_env(void)
+{
+	const char *fdtfile;
+
+	m2_power_enable();
+	set_m2_load_info(&fdtfile);
+	env_set("fdtfile", fdtfile);
+	env_save();
+}
+
 int board_init(void)
 {
 	return 0;
@@ -216,6 +466,8 @@ int board_late_init(void)
 	writel(0x3, SERDES0_LANE_SELECT);
 
 	set_board_info_env();
+	if (board_is_m2())
+		update_m2_board_info_env();
 
 	/* remove the eMMC if requested via button */
 	if (IS_ENABLED(CONFIG_IOT2050_BOOT_SWITCH) && board_is_advanced() &&
@@ -225,6 +477,16 @@ int board_late_init(void)
 	return 0;
 }
 
+static void m2_fdt_fixup(void *blob)
+{
+	int ret;
+
+	ret = fdt_find_and_setprop(blob, "/", "compatible", fdt_fix_string,
+								strlen(fdt_fix_string) + 1, 0);
+	if (ret)
+		pr_err("%s: m.2 fdt fixup failed:%d\n", __func__, ret);
+}
+
 #if defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP)
 int ft_board_setup(void *blob, struct bd_info *bd)
 {
@@ -237,6 +499,9 @@ int ft_board_setup(void *blob, struct bd_info *bd)
 	if (ret)
 		pr_err("%s: fixing up msmc ram failed %d\n", __func__, ret);
 
+	if (board_is_m2())
+		m2_fdt_fixup(blob);
+
 	return ret;
 }
 #endif
-- 
2.30.2

